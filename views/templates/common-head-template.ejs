<!--
common-head-template includes the html elements shared between views, such
as the <head> and shared javascript.
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Flux VR</title>
  <link rel="stylesheet" type="text/css" href="/public/main.css">

  <!-- Unity autogenerated files -->
  <link rel="stylesheet" href="TemplateData/style.css">
  <script src="TemplateData/UnityProgress.js"></script>

  <!-- Flux SDK -->
  <script type="text/javascript" src="https://npmcdn.com/flux-sdk-browser@0.3.0/dist/flux-sdk-min.js"></script>

  <!-- Flux Data Selector -->
  <script type="text/javascript" src="flux-data-selector/flux-data-selector.js"></script>

  <!-- Jquery -->
  <script src="//code.jquery.com/jquery-1.10.2.min.js"></script>

  <!-- Semantic UI -->
  <link rel="stylesheet" type="text/css" href="flux-data-selector/semantic/semantic.min.css">
  <script type="text/javascript" src="flux-data-selector/semantic/semantic.min.js"></script>
</head>

<h1 class="center display-on-load ui segment">Flux-Unity Viewer</h1>

<script>
  (function(context) {

    // Prevent the scary "WebGL not supported on mobile!" message in
    // Unity's autogenerated code. Nothing is supposed to depend on
    // window.userAgent or .vendor, but it could mess up analytics.
    // Use this at your own risk.
    navigator.__defineGetter__('userAgent', function(){ return ' '; });
    navigator.__defineGetter__('vendor', function(){ return ' '; });

    // Loaded is called when the webgl viewport finishes loading.
    function Loaded(arg) {

      // Search the url for a project and keys.
      var proj = (x = /[?&](project)=([\d\w]*)/.exec(context.location.search)) ?
        x[2] : null;
      if (proj && localStorage.getItem('fluxCredentials')) {
        context.ds.selectProject(proj);
        var noMatches = true, regex = /[?&](key)=([\d\w]*)/g, result;
        while((result = regex.exec(context.location.search)) !== null) {
            noMatches = false;
            context.ds.selectKey(result[2])
        }
      } else {
        if (proj && !localStorage.getItem('fluxCredentials')) {
          window.showError("You're trying to view a Flux Project, but you're " +
            "not logged into Flux! Try logging in first.");
        } else if (!proj) {
          window.showError("Welcome! We've provided an example building " +
            "to get you started. Log in to Flux with the + button " +
            "to see your own buildings!");
        }
        context.ds.selectExample("thomas' building");
      }

      var position =
        (y = /[?&](position)=(\((-?\d+\.\d+),(-?\d+\.\d+),(-?\d+\.\d+)\)\((-?\d+\.\d+),(-?\d+\.\d+),(-?\d+\.\d+)\))/
          .exec(context.location.search)) ?
        y[2] : null;
      if (position) {
        setTimeout(function() {
          SendMessage("player", "SetPosition", position);
        }, 200);
      }

      context.keyListModule.completeInitialLoading();

      var closeButtons = document.querySelectorAll('.close-panels-button');
      Array.prototype.forEach.call(closeButtons, function(item) {
        item.addEventListener('click', closePanels);
      });
    }

    context.Loaded = Loaded;

    // Sets the size of loaded geometry in the Unity context.
    // Currently hidden due to a bug.
    // function sizeInputHandler(e) {
    //   if (/[^\d]/.exec(e.target.value)) return;
    //   SendMessage("flux", "SetSize", parseFloat(e.target.value));

    //   var input = document.querySelector('.size-input');
    //   while (input.firstChild) {
    //     input.removeChild(input.firstChild);
    //   }
    //   var sizeChangedMessage = document.createElement('p');
    //   sizeChangedMessage.textContent = "Changed size to " + e.target.value;
    //   // append this somewhere
    // }
    // document.querySelector('.size-input')
    // .addEventListener('change', sizeInputHandler);

  })(window);
</script>

